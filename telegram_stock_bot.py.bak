import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    MessageHandler,
    filters,
)
import requests
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import asyncio

# Configuration
ALPHA_VANTAGE_API_KEY = "AYYXA7DKK82SNWS2"  # Replace with your API key
TELEGRAM_BOT_TOKEN = "7492489732:AAEakynsDCp_FjWgwXp29ghHAs4WKIdpRww"  # Replace with your bot token
ALERTS = {}  # Store user alerts: {chat_id: {symbol: threshold}}

# Logging setup
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Fetch stock data from Alpha Vantage
def fetch_stock_data(symbol):
    url = f"https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={symbol}&apikey={ALPHA_VANTAGE_API_KEY}"
    response = requests.get(url)
    data = response.json()
    if "Time Series (Daily)" not in data:
        return None
    return data["Time Series (Daily)"]

# Get current stock price
def get_current_price(symbol):
    data = fetch_stock_data(symbol)
    if not data:
        return None
    latest_date = max(data.keys())
    return float(data[latest_date]["4. close"])

# Calculate moving averages
def calculate_moving_averages(symbol, days):
    data = fetch_stock_data(symbol)
    if not data:
        return None
    df = pd.DataFrame.from_dict(data, orient="index")["4. close"].astype(float)
    df = df.sort_index()  # Ensure chronological order
    return df.rolling(window=days).mean().iloc[-1]

# Generate price chart
def generate_chart(symbol):
    data = fetch_stock_data(symbol)
    if not data:
        return None
    df = pd.DataFrame.from_dict(data, orient="index")["4. close"].astype(float)
    df = df.sort_index()[-30:]  # Last 30 days
    plt.figure(figsize=(10, 5))
    plt.plot(df.index, df.values, label=f"{symbol} Price")
    plt.title(f"{symbol} Stock Price (Last 30 Days)")
    plt.xlabel("Date")
    plt.ylabel("Price (USD)")
    plt.xticks(rotation=45)
    plt.legend()
    plt.tight_layout()
    chart_path = f"{symbol}_chart.png"
    plt.savefig(chart_path)
    plt.close()
    return chart_path

# Check price alerts
async def check_alerts(context: ContextTypes.DEFAULT_TYPE):
    for chat_id, alerts in ALERTS.items():
        for symbol, threshold in alerts.items():
            current_price = get_current_price(symbol)
            if current_price and current_price >= threshold:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"Alert: {symbol} has reached ${current_price:.2f}, exceeding your threshold of ${threshold:.2f}!"
                )
                del ALERTS[chat_id][symbol]  # Remove alert after triggering

# Start command
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("Get Price", callback_data="price")],
        [InlineKeyboardButton("Moving Averages", callback_data="ma")],
        [InlineKeyboardButton("Set Alert", callback_data="alert")],
        [InlineKeyboardButton("View Chart", callback_data="chart")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "Welcome to the Stock Bot! Select an option:", reply_markup=reply_markup
    )

# Handle button clicks
async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data["action"] = query.data
    if query.data == "price":
        await query.message.reply_text("Enter stock symbol (e.g., AAPL):")
    elif query.data == "ma":
        await query.message.reply_text("Enter stock symbol for moving averages:")
    elif query.data == "alert":
        await query.message.reply_text("Enter stock symbol and price threshold (e.g., AAPL 100):")
    elif query.data == "chart":
        await query.message.reply_text("Enter stock symbol for price chart:")

# Handle text input
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    chat_id = update.message.chat_id
    action = context.user_data.get("action")

    if action == "price":
        price = get_current_price(text.upper())
        if price:
            await update.message.reply_text(f"Current price of {text.upper()}: ${price:.2f}")
        else:
            await update.message.reply_text("Invalid symbol or API error.")
    elif action == "ma":
        symbol = text.upper()
        ma7 = calculate_moving_averages(symbol, 7)
        ma14 = calculate_moving_averages(symbol, 14)
        if ma7 and ma14:
            await update.message.reply_text(
                f"{symbol} Moving Averages:\n7-day: ${ma7:.2f}\n14-day: ${ma14:.2f}"
            )
        else:
            await update.message.reply_text("Invalid symbol or API error.")
    elif action == "alert":
        try:
            symbol, threshold = text.split()
            symbol = symbol.upper()
            threshold = float(threshold)
            if chat_id not in ALERTS:
                ALERTS[chat_id] = {}
            ALERTS[chat_id][symbol] = threshold
            await update.message.reply_text(
                f"Alert set for {symbol} at ${threshold:.2f}."
            )
        except ValueError:
            await update.message.reply_text("Please enter symbol and threshold (e.g., AAPL 100).")
    elif action == "chart":
        symbol = text.upper()
        chart_path = generate_chart(symbol)
        if chart_path:
            with open(chart_path, "rb") as photo:
                await update.message.reply_photo(photo=photo)
            os.remove(chart_path)
        else:
            await update.message.reply_text("Invalid symbol or API error.")
    else:
        await update.message.reply_text("Please select an option from the menu.")

def main():
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    # Schedule alert checks every 60 seconds
    application.job_queue.run_repeating(check_alerts, interval=60, first=10)

    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()